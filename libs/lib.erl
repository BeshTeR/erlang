%%% ----------------------------------------------------------------------------
%%% @author Oleg Muraviev <avesh.net@bk.ru>
%%%
%%% @doc Библиотека некоторых часто используемых функций
%%% @end
%%% ----------------------------------------------------------------------------
-module(lib).

%% API
-export([gcd/2, sign/1, pow/2, fac/1, id/1, map/2, filter/2, flush/0]).

%% Tests
-include("tests/lib_tests.erl").

%% -----------------------------------------------------------------------------
%% @doc Вычисление целой степени числа
%% @end
%% -----------------------------------------------------------------------------
-spec pow(Base, Degree) -> Return when
    Base   :: number(),
    Degree :: integer(),
    Return :: number().

pow(Base, Degree) when is_number(Base), is_integer(Degree) ->
    case Degree >= 0 of
        true  -> pow(Base, Degree, 1);
        false -> 1/pow(Base, -Degree, 1)
    end.

% тело pow с аккумулятором
pow(_, 0, Acc) ->
    Acc;
pow(N, M, Acc) when M rem 2 == 0 ->
    pow(N*N, M div 2, Acc);
pow(N, M, Acc) ->
    pow(N, M-1, N*Acc).

%% -----------------------------------------------------------------------------
%% @doc Факториал числа
%% @end
%% -----------------------------------------------------------------------------
-spec fac(Num) -> Return when
    Num    :: non_neg_integer(),
    Return :: pos_integer().

fac(Num) when is_integer(Num), Num >=0 ->
    fac(Num, 1).

%% тело fac с аккумулятором
fac(0, Acc) ->
    Acc;
fac(N, Acc) ->
    fac(N-1, N*Acc).

%% -----------------------------------------------------------------------------
%% @doc Наибольший общий делитель двух целых чисел
%% @end
%% -----------------------------------------------------------------------------
-spec gcd(N, M) -> Return when
    N      :: integer(),
    M      :: integer(),
    Return :: pos_integer().

gcd(N, 0) ->
    abs(N);
gcd(N, M) ->
    gcd(M, N rem M).

%% -----------------------------------------------------------------------------
%% @doc Знак числа
%% @end
%% -----------------------------------------------------------------------------
-spec sign(Num) -> Return when
    Num    :: number(),
    Return :: -1 | 0 | 1.

sign(Num) when Num == 0 -> 0;
sign(Num) when is_number(Num) ->
    case Num > 0 of
        true  -> 1;
        false -> -1
    end.

%% -----------------------------------------------------------------------------
%% @doc Функция, возвращающая свой аргумент
%% @end
%% -----------------------------------------------------------------------------
-spec id(Term) -> Return when
    Term   :: any(),
    Return :: any().

id(Term) ->
    Term.

%% -----------------------------------------------------------------------------
%% @doc Применить функцию ко всем элементам списка
%% @end
%% -----------------------------------------------------------------------------
-spec map(F, L) -> Return when
    F      :: fun(),
    L      :: [any()],
    Return :: [any()].

map(F, L) ->
    [F(X) || X <- L].

%% -----------------------------------------------------------------------------
%% @doc Фильтрация списка по условию
%% @end
%% -----------------------------------------------------------------------------
-spec filter(P, L) -> Return when
    P      :: fun(),
    L      :: [any()],
    Return :: [any()].

filter(P, L) ->
    [X || X <- L, P(X)].

%% -----------------------------------------------------------------------------
%% @doc Очистка очереди сообщений текущего процесса
%% @end
%% -----------------------------------------------------------------------------
-spec flush() -> Return when
    Return :: ok.

flush() ->
    receive
        _ -> flush()
    after
        0 -> ok
    end.
